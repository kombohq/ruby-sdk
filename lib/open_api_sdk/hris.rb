# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true

require 'faraday'
require 'faraday/multipart'
require 'faraday/retry'
require 'sorbet-runtime'
require 'janeway'
require_relative 'sdk_hooks/hooks'
require_relative 'utils/retries'

module OpenApiSDK
  extend T::Sig
  class Hris
    extend T::Sig
    


    sig { params(sdk_config: SDKConfiguration).void }
    def initialize(sdk_config)
      @sdk_configuration = sdk_config
      
    end

    sig { params(base_url: String, url_variables: T.nilable(T::Hash[Symbol, T.any(String, T::Enum)])).returns(String) }
    def get_url(base_url:, url_variables: nil)
      sd_base_url, sd_options = @sdk_configuration.get_server_details

      if base_url.nil?
        base_url = sd_base_url
      end

      if url_variables.nil?
        url_variables = sd_options
      end

      return Utils.template_url base_url, url_variables
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), employment_statuses: T.nilable(T::Array[::String]), group_ids: T.nilable(T::Array[::String]), legal_entity_ids: T.nilable(T::Array[::String]), work_location_ids: T.nilable(T::Array[::String]), work_emails: T.nilable(T::Array[::String]), personal_emails: T.nilable(T::Array[::String]), custom_fields: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetHrisEmployeesResponse) }
    def get_employees(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, employment_statuses: nil, group_ids: nil, legal_entity_ids: nil, work_location_ids: nil, work_emails: nil, personal_emails: nil, custom_fields: nil, timeout_ms: nil)
      # get_employees - Get employees
      # Retrieve all employees.
      # 
      # <Note>Not interested in most fields? You can use our [our Scopes feature](/scopes) to customize what data points are synced.</Note>
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetHrisEmployeesRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids,
        employment_statuses: employment_statuses,
        group_ids: group_ids,
        legal_entity_ids: legal_entity_ids,
        work_location_ids: work_location_ids,
        work_emails: work_emails,
        personal_emails: personal_emails,
        custom_fields: custom_fields
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/hris/employees"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetHrisEmployeesRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetHrisEmployees',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetHrisEmployeesPositiveResponse)
          response = Models::Operations::GetHrisEmployeesResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_hris_employees_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_employees(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids,
              employment_statuses: employment_statuses,
              group_ids: group_ids,
              legal_entity_ids: legal_entity_ids,
              work_location_ids: work_location_ids,
              work_emails: work_emails,
              personal_emails: personal_emails,
              custom_fields: custom_fields
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboHrisError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(integration_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetHrisEmployeesFormResponse) }
    def get_employee_form(integration_id: nil, timeout_ms: nil)
      # get_employee_form - Get employee form
      # Get the form for creating an employee. This form can be rendered dynamically on your frontend to allow your customers to create employees in their HRIS.
      # 
      # Follow our [create employee guide here](/hris/features/create-employee) to learn how this form is generated and how you can use it.
      # 
      # ### Example Form
      # ```json
      # {
      #   "properties": {
      #     "firstName": {
      #       "type": "text",
      #       "label": "First Name",
      #       "required": true,
      #       "description": "Employee's first name",
      #       "unified_key": "first_name",
      #       "min_length": 1,
      #       "max_length": 100
      #     },
      #     "startDate": {
      #       "type": "date",
      #       "label": "Start Date",
      #       "required": true,
      #       "description": "Employee's start date",
      #       "unified_key": "start_date"
      #     },
      #     "workLocation": {
      #       "type": "object",
      #       "label": "Work Location",
      #       "required": false,
      #       "description": "Employee's work location",
      #       "unified_key": null,
      #       "properties": {
      #         "site": {
      #           "type": "single_select",
      #           "label": "Site",
      #           "required": true,
      #           "description": "Employee's site",
      #           "unified_key": null,
      #           "options": {
      #             "type": "inline",
      #             "entries": [
      #               {
      #                 "label": "Site 1",
      #                 "id": "FXrER44xubBqA9DLgZ3PFNNx",
      #                 "unified_value": "1",
      #                 "remote_id": "site_1"
      #               },
      #               {
      #                 "label": "Site 2",
      #                 "id": "2rv75UKT2XBoQXsUb9agiTUm",
      #                 "unified_value": "2",
      #                 "remote_id": "site_2"
      #               }
      #             ]
      #           }
      #         },
      #         "keyNumbers": {
      #           "type": "array",
      #           "label": "Key Numbers",
      #           "required": false,
      #           "description": "Employee's key numbers",
      #           "unified_key": null,
      #           "min_items": 2,
      #           "max_items": 5,
      #           "item_type": {
      #             "type": "number",
      #             "label": "Key Number",
      #             "required": false,
      #             "description": "The number of the keys which belong to the employee",
      #             "unified_key": null,
      #             "min": 0,
      #             "max": 99
      #           }
      #         }
      #       }
      #     }
      #   }
      # }
      # ```
      request = Models::Operations::GetHrisEmployeesFormRequest.new(
        integration_id: integration_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/hris/employees/form"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetHrisEmployeesForm',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetHrisEmployeesFormPositiveResponse)
          response = Models::Operations::GetHrisEmployeesFormResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_hris_employees_form_positive_response: T.unsafe(obj)
          )

          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboHrisError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(body: Models::Shared::PostHrisEmployeesFormRequestBody, integration_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::PostHrisEmployeesFormResponse) }
    def create_employee_with_form(body:, integration_id: nil, timeout_ms: nil)
      # create_employee_with_form - Create employee with form
      # Create an employee, based on the form schema.
      # 
      # <Note>
      #   This endpoint requires the permission **Create and manage employees** to be enabled in [your scope config](/scopes).
      # </Note>
      # 
      # ### Example Request Body
      # 
      # ```json
      # {
      #   "properties": {
      #     "firstName": "John",
      #     "startDate": "2025-01-01",
      #     "workLocation": {
      #       "site": "8e422bf8cav",
      #       "keyNumbers": [
      #         142,
      #         525,
      #         63
      #       ]
      #     }
      #   }
      # }
      # ```
      request = Models::Operations::PostHrisEmployeesFormRequest.new(
        body: body,
        integration_id: integration_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/hris/employees/form"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      req_content_type, data, form = Utils.serialize_request_body(request, false, false, :body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?

      if form
        body = Utils.encode_form(form)
      elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
        body = URI.encode_www_form(T.cast(data, T::Hash[Symbol, Object]))
      else
        body = data
      end
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'PostHrisEmployeesForm',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).post(url) do |req|
          req.body = body
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::PostHrisEmployeesFormPositiveResponse)
          response = Models::Operations::PostHrisEmployeesFormResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            post_hris_employees_form_positive_response: T.unsafe(obj)
          )

          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboHrisError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(body: Models::Shared::PostHrisEmployeesEmployeeIdDocumentsRequestBody, employee_id: ::String, integration_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::PostHrisEmployeesEmployeeIdDocumentsResponse) }
    def add_employee_document(body:, employee_id:, integration_id: nil, timeout_ms: nil)
      # add_employee_document - Add document to employee
      # Uploads an document file for the specified employee.
      # 
      # <Note>
      #   This endpoint requires the permission **Manage documents** to be enabled in [your scope config](/scopes).
      # </Note>
      # 
      # ### Example Request Body
      # 
      # ```json
      # {
      #   "category_id": "3Cjwu7nA7pH5cX5X1NAPmb7M",
      #   "document": {
      #     "name": "Frank Doe Employment Contract.txt",
      #     "data": "SGkgdGhlcmUsIEtvbWJvIGlzIGN1cnJlbnRseSBoaXJpbmcgZW5naW5lZXJzIHRoYXQgbG92ZSB0byB3b3JrIG9uIGRldmVsb3BlciBwcm9kdWN0cy4=",
      #     "content_type": "text/plain"
      #   }
      # }
      # ```
      request = Models::Operations::PostHrisEmployeesEmployeeIdDocumentsRequest.new(
        employee_id: employee_id,
        body: body,
        integration_id: integration_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        Models::Operations::PostHrisEmployeesEmployeeIdDocumentsRequest,
        base_url,
        '/hris/employees/{employee_id}/documents',
        request,
        @sdk_configuration.globals
      )
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      req_content_type, data, form = Utils.serialize_request_body(request, false, false, :body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?

      if form
        body = Utils.encode_form(form)
      elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
        body = URI.encode_www_form(T.cast(data, T::Hash[Symbol, Object]))
      else
        body = data
      end
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'PostHrisEmployeesEmployeeIdDocuments',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).post(url) do |req|
          req.body = body
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::PostHrisEmployeesEmployeeIdDocumentsPositiveResponse)
          response = Models::Operations::PostHrisEmployeesEmployeeIdDocumentsResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            post_hris_employees_employee_id_documents_positive_response: T.unsafe(obj)
          )

          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboHrisError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetHrisEmployeeDocumentCategoriesResponse) }
    def get_employee_document_categories(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, timeout_ms: nil)
      # get_employee_document_categories - Get employee document categories
      # Get employee document categories.
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetHrisEmployeeDocumentCategoriesRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/hris/employee-document-categories"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetHrisEmployeeDocumentCategoriesRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetHrisEmployeeDocumentCategories',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetHrisEmployeeDocumentCategoriesPositiveResponse)
          response = Models::Operations::GetHrisEmployeeDocumentCategoriesResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_hris_employee_document_categories_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_employee_document_categories(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboHrisError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), types: T.nilable(T::Array[::String]), name_contains: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetHrisGroupsResponse) }
    def get_groups(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, types: nil, name_contains: nil, timeout_ms: nil)
      # get_groups - Get groups
      # Retrieve all "groups" (teams, departments, and cost centers).
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetHrisGroupsRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids,
        types: types,
        name_contains: name_contains
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/hris/groups"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetHrisGroupsRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetHrisGroups',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetHrisGroupsPositiveResponse)
          response = Models::Operations::GetHrisGroupsResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_hris_groups_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_groups(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids,
              types: types,
              name_contains: name_contains
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboHrisError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetHrisEmploymentsResponse) }
    def get_employments(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, timeout_ms: nil)
      # get_employments - Get employments
      # Retrieve all employments.
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetHrisEmploymentsRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/hris/employments"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetHrisEmploymentsRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetHrisEmployments',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetHrisEmploymentsPositiveResponse)
          response = Models::Operations::GetHrisEmploymentsResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_hris_employments_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_employments(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboHrisError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), name_contains: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetHrisLocationsResponse) }
    def get_locations(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, name_contains: nil, timeout_ms: nil)
      # get_locations - Get work locations
      # Retrieve all work locations.
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetHrisLocationsRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids,
        name_contains: name_contains
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/hris/locations"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetHrisLocationsRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetHrisLocations',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetHrisLocationsPositiveResponse)
          response = Models::Operations::GetHrisLocationsResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_hris_locations_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_locations(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids,
              name_contains: name_contains
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboHrisError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetHrisAbsenceTypesResponse) }
    def get_absence_types(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, timeout_ms: nil)
      # get_absence_types - Get absence types
      # Retrieve all absence types.
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetHrisAbsenceTypesRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/hris/absence-types"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetHrisAbsenceTypesRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetHrisAbsenceTypes',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetHrisAbsenceTypesPositiveResponse)
          response = Models::Operations::GetHrisAbsenceTypesResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_hris_absence_types_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_absence_types(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboHrisError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), employee_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetHrisTimeOffBalancesResponse) }
    def get_time_off_balances(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, employee_id: nil, timeout_ms: nil)
      # get_time_off_balances - Get time off balances
      # Retrieve all time off balances.
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetHrisTimeOffBalancesRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids,
        employee_id: employee_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/hris/time-off-balances"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetHrisTimeOffBalancesRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetHrisTimeOffBalances',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetHrisTimeOffBalancesPositiveResponse)
          response = Models::Operations::GetHrisTimeOffBalancesResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_hris_time_off_balances_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_time_off_balances(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids,
              employee_id: employee_id
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboHrisError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), date_from: T.nilable(::DateTime), date_until: T.nilable(::DateTime), type_ids: T.nilable(T::Array[::String]), employee_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetHrisAbsencesResponse) }
    def get_absences(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, date_from: nil, date_until: nil, type_ids: nil, employee_id: nil, timeout_ms: nil)
      # get_absences - Get absences
      # Retrieve all absences.
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetHrisAbsencesRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids,
        date_from: date_from,
        date_until: date_until,
        type_ids: type_ids,
        employee_id: employee_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/hris/absences"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetHrisAbsencesRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetHrisAbsences',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetHrisAbsencesPositiveResponse)
          response = Models::Operations::GetHrisAbsencesResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_hris_absences_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_absences(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids,
              date_from: date_from,
              date_until: date_until,
              type_ids: type_ids,
              employee_id: employee_id
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboHrisError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(body: Models::Shared::PostHrisAbsencesRequestBody, integration_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::PostHrisAbsencesResponse) }
    def create_absence(body:, integration_id: nil, timeout_ms: nil)
      # create_absence - Create absence
      # Create a new absence.
      # 
      # Check [this page](/hris/features/creating-absences) for a detailed guide.
      # 
      # <Note>
      #   This endpoint requires the permission **Manage absences** to be enabled in [your scope config](/scopes).
      # </Note>
      # 
      # ### Example Request Body
      # 
      # ```json
      # {
      #   "employee_id": "wXJMxwDvPAjrJ4CyqdV9",
      #   "absence_type_id": "3YKtQ7qedsrcCady1jSyAkY1",
      #   "start_date": "2019-09-17",
      #   "end_date": "2019-09-21",
      #   "start_time": "08:30:00",
      #   "end_time": "16:00:00",
      #   "start_half_day": false,
      #   "end_half_day": false,
      #   "employee_note": "Visiting the aliens"
      # }
      # ```
      request = Models::Operations::PostHrisAbsencesRequest.new(
        body: body,
        integration_id: integration_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/hris/absences"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      req_content_type, data, form = Utils.serialize_request_body(request, false, false, :body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?

      if form
        body = Utils.encode_form(form)
      elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
        body = URI.encode_www_form(T.cast(data, T::Hash[Symbol, Object]))
      else
        body = data
      end
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'PostHrisAbsences',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).post(url) do |req|
          req.body = body
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::PostHrisAbsencesPositiveResponse)
          response = Models::Operations::PostHrisAbsencesResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            post_hris_absences_positive_response: T.unsafe(obj)
          )

          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboHrisError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(body: Models::Shared::DeleteHrisAbsencesAbsenceIdRequestBody, absence_id: ::String, integration_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::DeleteHrisAbsencesAbsenceIdResponse) }
    def delete_absence(body:, absence_id:, integration_id: nil, timeout_ms: nil)
      # delete_absence - Delete absence
      # Delete this absence.
      # 
      # <Note>
      #   This endpoint requires the permission **Manage absences** to be enabled in [your scope config](/scopes).
      # </Note>
      # 
      # ### Example Request Body
      # 
      # ```json
      # {
      #   "absence_id": "wXJMxwDvPAjrJ4CyqdV9"
      # }
      # ```
      request = Models::Operations::DeleteHrisAbsencesAbsenceIdRequest.new(
        absence_id: absence_id,
        body: body,
        integration_id: integration_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        Models::Operations::DeleteHrisAbsencesAbsenceIdRequest,
        base_url,
        '/hris/absences/{absence_id}',
        request,
        @sdk_configuration.globals
      )
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      req_content_type, data, form = Utils.serialize_request_body(request, false, false, :body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?

      if form
        body = Utils.encode_form(form)
      elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
        body = URI.encode_www_form(T.cast(data, T::Hash[Symbol, Object]))
      else
        body = data
      end
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'DeleteHrisAbsencesAbsenceId',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).delete(url) do |req|
          req.body = body
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::DeleteHrisAbsencesAbsenceIdPositiveResponse)
          response = Models::Operations::DeleteHrisAbsencesAbsenceIdResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            delete_hris_absences_absence_id_positive_response: T.unsafe(obj)
          )

          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboHrisError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), name_contains: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetHrisLegalEntitiesResponse) }
    def get_legal_entities(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, name_contains: nil, timeout_ms: nil)
      # get_legal_entities - Get legal entities
      # Retrieve all legal entites.
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetHrisLegalEntitiesRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids,
        name_contains: name_contains
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/hris/legal-entities"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetHrisLegalEntitiesRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetHrisLegalEntities',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetHrisLegalEntitiesPositiveResponse)
          response = Models::Operations::GetHrisLegalEntitiesResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_hris_legal_entities_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_legal_entities(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids,
              name_contains: name_contains
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboHrisError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), employee_id: T.nilable(::String), started_before: T.nilable(::DateTime), started_after: T.nilable(::DateTime), ended_before: T.nilable(::DateTime), ended_after: T.nilable(::DateTime), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetHrisTimesheetsResponse) }
    def get_timesheets(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, employee_id: nil, started_before: nil, started_after: nil, ended_before: nil, ended_after: nil, timeout_ms: nil)
      # get_timesheets - Get timesheets
      # Get timesheets
      # 
      # Retrieve attendance data and timesheets from HRIS tools.
      # 
      # <Warning>**Open Beta Feature:** This endpoint is currently in beta. Please reach out to our support team if you need assistance with implementation.</Warning>
      # 
      # For a detailed explanation of the data model, validation rules, time zones, payable hours, approvals, and break patterns, see the [Time & Attendance guide](/hris/features/time-and-attendance).
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetHrisTimesheetsRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids,
        employee_id: employee_id,
        started_before: started_before,
        started_after: started_after,
        ended_before: ended_before,
        ended_after: ended_after
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/hris/timesheets"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetHrisTimesheetsRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetHrisTimesheets',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetHrisTimesheetsPositiveResponse)
          response = Models::Operations::GetHrisTimesheetsResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_hris_timesheets_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_timesheets(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids,
              employee_id: employee_id,
              started_before: started_before,
              started_after: started_after,
              ended_before: ended_before,
              ended_after: ended_after
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboHrisError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetHrisPerformanceReviewCyclesResponse) }
    def get_performance_review_cycles(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, timeout_ms: nil)
      # get_performance_review_cycles - Get performance review cycles
      # Get performance review cycles
      # 
      # Retrieve performance review cycles data from HRIS tools.
      # 
      # <Warning>**Open Beta Feature:** This endpoint is currently in beta. Please reach out to our support team if you need assistance with implementation.</Warning>
      # 
      # 
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetHrisPerformanceReviewCyclesRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/hris/performance-review-cycles"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetHrisPerformanceReviewCyclesRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetHrisPerformanceReviewCycles',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetHrisPerformanceReviewCyclesPositiveResponse)
          response = Models::Operations::GetHrisPerformanceReviewCyclesResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_hris_performance_review_cycles_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_performance_review_cycles(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboHrisError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), types: T.nilable(T::Array[::String]), review_cycle_ids: T.nilable(T::Array[::String]), reviewee_ids: T.nilable(T::Array[::String]), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetHrisPerformanceReviewsResponse) }
    def get_performance_reviews(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, types: nil, review_cycle_ids: nil, reviewee_ids: nil, timeout_ms: nil)
      # get_performance_reviews - Get performance reviews
      # Get performance reviews
      # 
      # Retrieve performance review data from HRIS tools.
      # 
      # <Warning>**Open Beta Feature:** This endpoint is currently in beta. Please reach out to our support team if you need assistance with implementation.</Warning>
      # 
      # 
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetHrisPerformanceReviewsRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids,
        types: types,
        review_cycle_ids: review_cycle_ids,
        reviewee_ids: reviewee_ids
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/hris/performance-reviews"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetHrisPerformanceReviewsRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetHrisPerformanceReviews',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetHrisPerformanceReviewsPositiveResponse)
          response = Models::Operations::GetHrisPerformanceReviewsResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_hris_performance_reviews_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_performance_reviews(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids,
              types: types,
              review_cycle_ids: review_cycle_ids,
              reviewee_ids: reviewee_ids
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboHrisError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end
  end
end
