# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true


module OpenApiSDK
  module Models
    module Operations

      class GetHrisEmployeesRequest
        extend T::Sig
        include Crystalline::MetadataFields

        # ID of the integration you want to interact with.
        field :integration_id, Crystalline::Nilable.new(::String), { 'header': { 'field_name': 'X-Integration-Id', 'style': 'simple', 'explode': false } }
        # An optional cursor string used for pagination. This can be retrieved from the `next` property of the previous page response.
        field :cursor, Crystalline::Nilable.new(::String), { 'query_param': { 'field_name': 'cursor', 'style': 'form', 'explode': true } }
        # Filter the entries based on the modification date in format `YYYY-MM-DDTHH:mm:ss.sssZ`. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record's own `changed_at` field remains unchanged.
        # 
        # If you want to track entry deletion, also set the `include_deleted=true` query parameter, because otherwise, deleted entries will be hidden.
        # 
        # For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
        field :updated_after, Crystalline::Nilable.new(::DateTime), { 'query_param': { 'field_name': 'updated_after', 'style': 'form', 'explode': true } }
        # Filter by a comma-separated list of IDs such as `222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3`.
        field :ids, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'query_param': { 'field_name': 'ids', 'style': 'form', 'explode': false } }
        # Filter by a comma-separated list of remote IDs.
        field :remote_ids, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'query_param': { 'field_name': 'remote_ids', 'style': 'form', 'explode': false } }
        # Filter by a comma-separated list of `ACTIVE`, `PENDING`, `INACTIVE`, `LEAVE` 
        # * `ACTIVE`: the employee is **actively employed** 
        # * `PENDING`: the employee is **not actively employed yet** (but they signed their contract or are part of an onboarding process) 
        # * `INACTIVE`: a full-time employee is no longer employed, or, for a contract worker when their contract runs out 
        # * `LEAVE`: the employee is still employed but **currently on leave** (note that not all HR systems support this status â€” use our absences API for detailed information) 
        #  
        # 
        # Leave this blank to get results matching all values.
        field :employment_statuses, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'query_param': { 'field_name': 'employment_statuses', 'style': 'form', 'explode': false } }
        # Filter by a comma-separated list of group IDs. We will only return employees that are members of _any_ of the groups.
        field :group_ids, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'query_param': { 'field_name': 'group_ids', 'style': 'form', 'explode': false } }
        # Filter by a comma-separated list of legal entity IDs. We will only return employees that are members of _any_ of the legal entities.
        field :legal_entity_ids, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'query_param': { 'field_name': 'legal_entity_ids', 'style': 'form', 'explode': false } }
        # Filter by a comma-separated list of work location IDs. We will only return employees who are at _any_ of the work locations.
        field :work_location_ids, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'query_param': { 'field_name': 'work_location_ids', 'style': 'form', 'explode': false } }
        # Filter by a comma-separated list of work emails. We will only return employees who have _any_ of the work emails. The format of the emails is case-insensitive.
        field :work_emails, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'query_param': { 'field_name': 'work_emails', 'style': 'form', 'explode': false } }
        # Filter by a comma-separated list of personal emails. We will only return employees who have _any_ of the personal emails. The format of the emails is case-insensitive.
        field :personal_emails, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'query_param': { 'field_name': 'personal_emails', 'style': 'form', 'explode': false } }
        # A JSON string with a single key-value pair like {"fieldKey":"fieldValue"} to filter employees by a specific custom field value. Note that the value must be a string, number, boolean or null and the key must be a valid custom field key. Custom fields with a value of type array or object are not supported.
        field :custom_fields, Crystalline::Nilable.new(::String), { 'query_param': { 'field_name': 'custom_fields', 'style': 'form', 'explode': true } }
        # The number of results to return per page. Maximum is 250.
        field :page_size, Crystalline::Nilable.new(::Integer), { 'query_param': { 'field_name': 'page_size', 'style': 'form', 'explode': true } }
        # By default, deleted entries are not returned. Use the `include_deleted` query param to include deleted entries too.
        field :include_deleted, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'query_param': { 'field_name': 'include_deleted', 'style': 'form', 'explode': true } }
        # When set to `true`, filters targeting fields not supported by this integration will be ignored instead of filtering out all results.
        field :ignore_unsupported_filters, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'query_param': { 'field_name': 'ignore_unsupported_filters', 'style': 'form', 'explode': true } }

        sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), updated_after: T.nilable(::DateTime), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), employment_statuses: T.nilable(T::Array[::String]), group_ids: T.nilable(T::Array[::String]), legal_entity_ids: T.nilable(T::Array[::String]), work_location_ids: T.nilable(T::Array[::String]), work_emails: T.nilable(T::Array[::String]), personal_emails: T.nilable(T::Array[::String]), custom_fields: T.nilable(::String), page_size: T.nilable(::Integer), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean)).void }
        def initialize(integration_id: nil, cursor: nil, updated_after: nil, ids: nil, remote_ids: nil, employment_statuses: nil, group_ids: nil, legal_entity_ids: nil, work_location_ids: nil, work_emails: nil, personal_emails: nil, custom_fields: nil, page_size: 100, include_deleted: false, ignore_unsupported_filters: false)
          @integration_id = integration_id
          @cursor = cursor
          @updated_after = updated_after
          @ids = ids
          @remote_ids = remote_ids
          @employment_statuses = employment_statuses
          @group_ids = group_ids
          @legal_entity_ids = legal_entity_ids
          @work_location_ids = work_location_ids
          @work_emails = work_emails
          @personal_emails = personal_emails
          @custom_fields = custom_fields
          @page_size = page_size
          @include_deleted = include_deleted
          @ignore_unsupported_filters = ignore_unsupported_filters
        end

        sig { params(other: T.untyped).returns(T::Boolean) }
        def ==(other)
          return false unless other.is_a? self.class
          return false unless @integration_id == other.integration_id
          return false unless @cursor == other.cursor
          return false unless @updated_after == other.updated_after
          return false unless @ids == other.ids
          return false unless @remote_ids == other.remote_ids
          return false unless @employment_statuses == other.employment_statuses
          return false unless @group_ids == other.group_ids
          return false unless @legal_entity_ids == other.legal_entity_ids
          return false unless @work_location_ids == other.work_location_ids
          return false unless @work_emails == other.work_emails
          return false unless @personal_emails == other.personal_emails
          return false unless @custom_fields == other.custom_fields
          return false unless @page_size == other.page_size
          return false unless @include_deleted == other.include_deleted
          return false unless @ignore_unsupported_filters == other.ignore_unsupported_filters
          true
        end
      end
    end
  end
end
