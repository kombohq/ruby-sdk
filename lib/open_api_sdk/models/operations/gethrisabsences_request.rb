# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true


module OpenApiSDK
  module Models
    module Operations

      class GetHrisAbsencesRequest
        extend T::Sig
        include Crystalline::MetadataFields

        # ID of the integration you want to interact with.
        field :integration_id, Crystalline::Nilable.new(::String), { 'header': { 'field_name': 'X-Integration-Id', 'style': 'simple', 'explode': false } }
        # An optional cursor string used for pagination. This can be retrieved from the `next` property of the previous page response.
        field :cursor, Crystalline::Nilable.new(::String), { 'query_param': { 'field_name': 'cursor', 'style': 'form', 'explode': true } }
        # Filter the entries based on the modification date in format `YYYY-MM-DDTHH:mm:ss.sssZ`. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record's own `changed_at` field remains unchanged.
        # 
        # If you want to track entry deletion, also set the `include_deleted=true` query parameter, because otherwise, deleted entries will be hidden.
        # 
        # For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
        field :updated_after, Crystalline::Nilable.new(::DateTime), { 'query_param': { 'field_name': 'updated_after', 'style': 'form', 'explode': true } }
        # Filter by a comma-separated list of IDs such as `222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3`.
        field :ids, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'query_param': { 'field_name': 'ids', 'style': 'form', 'explode': false } }
        # Filter by a comma-separated list of remote IDs.
        field :remote_ids, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'query_param': { 'field_name': 'remote_ids', 'style': 'form', 'explode': false } }
        # Filter for all the absences that either start _or_ haven't ended yet on/after this day. If you imagine a calendar displaying absences, this defines the left-most visible day. This is a plain date (i.e., `yyyy-MM-dd`), all time information is discarded.
        field :date_from, Crystalline::Nilable.new(::DateTime), { 'query_param': { 'field_name': 'date_from', 'style': 'form', 'explode': true } }
        # Filter for absences that start on or before this day (but might continue after). If you imagine a calendar displaying absences, this defines the right-most visible day. This is a plain date (i.e., `yyyy-MM-dd`), all time information is discarded.
        field :date_until, Crystalline::Nilable.new(::DateTime), { 'query_param': { 'field_name': 'date_until', 'style': 'form', 'explode': true } }
        # Filter by a comma-separated list of absence type IDs.
        field :type_ids, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'query_param': { 'field_name': 'type_ids', 'style': 'form', 'explode': false } }
        # Filter by a specific employee using their ID.
        field :employee_id, Crystalline::Nilable.new(::String), { 'query_param': { 'field_name': 'employee_id', 'style': 'form', 'explode': true } }
        # The number of results to return per page. Maximum is 250.
        field :page_size, Crystalline::Nilable.new(::Integer), { 'query_param': { 'field_name': 'page_size', 'style': 'form', 'explode': true } }
        # By default, deleted entries are not returned. Use the `include_deleted` query param to include deleted entries too.
        field :include_deleted, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'query_param': { 'field_name': 'include_deleted', 'style': 'form', 'explode': true } }
        # When set to `true`, filters targeting fields not supported by this integration will be ignored instead of filtering out all results.
        field :ignore_unsupported_filters, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'query_param': { 'field_name': 'ignore_unsupported_filters', 'style': 'form', 'explode': true } }

        sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), updated_after: T.nilable(::DateTime), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), date_from: T.nilable(::DateTime), date_until: T.nilable(::DateTime), type_ids: T.nilable(T::Array[::String]), employee_id: T.nilable(::String), page_size: T.nilable(::Integer), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean)).void }
        def initialize(integration_id: nil, cursor: nil, updated_after: nil, ids: nil, remote_ids: nil, date_from: nil, date_until: nil, type_ids: nil, employee_id: nil, page_size: 100, include_deleted: false, ignore_unsupported_filters: false)
          @integration_id = integration_id
          @cursor = cursor
          @updated_after = updated_after
          @ids = ids
          @remote_ids = remote_ids
          @date_from = date_from
          @date_until = date_until
          @type_ids = type_ids
          @employee_id = employee_id
          @page_size = page_size
          @include_deleted = include_deleted
          @ignore_unsupported_filters = ignore_unsupported_filters
        end

        sig { params(other: T.untyped).returns(T::Boolean) }
        def ==(other)
          return false unless other.is_a? self.class
          return false unless @integration_id == other.integration_id
          return false unless @cursor == other.cursor
          return false unless @updated_after == other.updated_after
          return false unless @ids == other.ids
          return false unless @remote_ids == other.remote_ids
          return false unless @date_from == other.date_from
          return false unless @date_until == other.date_until
          return false unless @type_ids == other.type_ids
          return false unless @employee_id == other.employee_id
          return false unless @page_size == other.page_size
          return false unless @include_deleted == other.include_deleted
          return false unless @ignore_unsupported_filters == other.ignore_unsupported_filters
          true
        end
      end
    end
  end
end
