# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true

require 'faraday'
require 'faraday/multipart'
require 'faraday/retry'
require 'sorbet-runtime'
require 'janeway'
require_relative 'sdk_hooks/hooks'
require_relative 'utils/retries'

module OpenApiSDK
  extend T::Sig
  class Ats
    extend T::Sig
    


    sig { params(sdk_config: SDKConfiguration).void }
    def initialize(sdk_config)
      @sdk_configuration = sdk_config
      
    end

    sig { params(base_url: String, url_variables: T.nilable(T::Hash[Symbol, T.any(String, T::Enum)])).returns(String) }
    def get_url(base_url:, url_variables: nil)
      sd_base_url, sd_options = @sdk_configuration.get_server_details

      if base_url.nil?
        base_url = sd_base_url
      end

      if url_variables.nil?
        url_variables = sd_options
      end

      return Utils.template_url base_url, url_variables
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), outcomes: T.nilable(T::Array[::String]), job_ids: T.nilable(T::Array[::String]), job_remote_ids: T.nilable(T::Array[::String]), current_stage_ids: T.nilable(T::Array[::String]), remote_created_after: T.nilable(::DateTime), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetAtsApplicationsResponse) }
    def get_applications(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, outcomes: nil, job_ids: nil, job_remote_ids: nil, current_stage_ids: nil, remote_created_after: nil, timeout_ms: nil)
      # get_applications - Get applications
      # Retrieve all applications.
      # 
      # Visit our in-depth guides to learn more about:
      # 
      # - ðŸ’¡ [Being aware of which applications are tracked](/ats/features/implementation-guide/tracking-created-applications#be-aware-of-which-applications-are-tracked)
      # - ðŸš¦ [Hiring signals](/ats/features/implementation-guide/tracking-created-applications#hiring-signals)
      # - ðŸ“ˆ [Application stage changes](/ats/features/implementation-guide/tracking-created-applications#application-stage-changes)
      # - â“ [ATS-specific limitations](/ats/features/implementation-guide/tracking-created-applications#ats-specific-limitations)
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetAtsApplicationsRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids,
        outcomes: outcomes,
        job_ids: job_ids,
        job_remote_ids: job_remote_ids,
        current_stage_ids: current_stage_ids,
        remote_created_after: remote_created_after
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/ats/applications"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetAtsApplicationsRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetAtsApplications',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetAtsApplicationsPositiveResponse)
          response = Models::Operations::GetAtsApplicationsResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_ats_applications_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_applications(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids,
              outcomes: outcomes,
              job_ids: job_ids,
              job_remote_ids: job_remote_ids,
              current_stage_ids: current_stage_ids,
              remote_created_after: remote_created_after
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(body: Models::Shared::PutAtsApplicationsApplicationIdStageRequestBody, application_id: ::String, integration_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::PutAtsApplicationsApplicationIdStageResponse) }
    def move_application_to_stage(body:, application_id:, integration_id: nil, timeout_ms: nil)
      # move_application_to_stage - Move application to stage
      # Moves an application to a specified stage. Use job-specific stages from GET /jobs, not the deprecated /application-stages endpoint.
      # 
      # <Note>
      #   This endpoint requires the permission **Set application stage** to be enabled in [your scope config](/scopes).
      # </Note>
      # 
      # ### Example Request Body
      # 
      # ```json
      # {
      #   "stage_id": "3PJ8PZhZZa1eEdd2DtPNtVup"
      # }
      # ```
      request = Models::Operations::PutAtsApplicationsApplicationIdStageRequest.new(
        application_id: application_id,
        body: body,
        integration_id: integration_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        Models::Operations::PutAtsApplicationsApplicationIdStageRequest,
        base_url,
        '/ats/applications/{application_id}/stage',
        request,
        @sdk_configuration.globals
      )
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      req_content_type, data, form = Utils.serialize_request_body(request, false, false, :body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?

      if form
        body = Utils.encode_form(form)
      elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
        body = URI.encode_www_form(T.cast(data, T::Hash[Symbol, Object]))
      else
        body = data
      end
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'PutAtsApplicationsApplicationIdStage',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).put(url) do |req|
          req.body = body
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::PutAtsApplicationsApplicationIdStagePositiveResponse)
          response = Models::Operations::PutAtsApplicationsApplicationIdStageResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            put_ats_applications_application_id_stage_positive_response: T.unsafe(obj)
          )

          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(body: Models::Shared::PostAtsApplicationsApplicationIdResultLinksRequestBody, application_id: ::String, integration_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::PostAtsApplicationsApplicationIdResultLinksResponse) }
    def add_application_result_link(body:, application_id:, integration_id: nil, timeout_ms: nil)
      # add_application_result_link - Add result link to application
      # Add a result link to an application.
      # 
      # This can, for example, be used to link a candidate back to a test result/assessment in your application. As not all ATS tools have a "result link" feature, we sometimes repurpose other fields to expose it.
      # 
      # <Note>
      #   This endpoint requires the permission **Add result links** to be enabled in [your scope config](/scopes).
      # </Note>
      # 
      # ### Example Request Body
      # 
      # ```json
      # {
      #   "application_id": "8Xi6iZrwusZqJmDGXs49GBmJ",
      #   "label": "Assessment Result",
      #   "url": "https://example.com/test-results/5BtP1WC1UboS7CF3yxjKcvjG",
      #   "details": {
      #     "custom_field_name_prefix": "Acme:",
      #     "attributes": [
      #       {
      #         "key": "Score",
      #         "value": "100%"
      #       },
      #       {
      #         "key": "Time",
      #         "value": "2:30h"
      #       }
      #     ]
      #   },
      #   "remote_fields": {}
      # }
      # ```
      request = Models::Operations::PostAtsApplicationsApplicationIdResultLinksRequest.new(
        application_id: application_id,
        body: body,
        integration_id: integration_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        Models::Operations::PostAtsApplicationsApplicationIdResultLinksRequest,
        base_url,
        '/ats/applications/{application_id}/result-links',
        request,
        @sdk_configuration.globals
      )
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      req_content_type, data, form = Utils.serialize_request_body(request, false, false, :body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?

      if form
        body = Utils.encode_form(form)
      elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
        body = URI.encode_www_form(T.cast(data, T::Hash[Symbol, Object]))
      else
        body = data
      end
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'PostAtsApplicationsApplicationIdResultLinks',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).post(url) do |req|
          req.body = body
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::PostAtsApplicationsApplicationIdResultLinksPositiveResponse)
          response = Models::Operations::PostAtsApplicationsApplicationIdResultLinksResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            post_ats_applications_application_id_result_links_positive_response: T.unsafe(obj)
          )

          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(body: Models::Shared::PostAtsApplicationsApplicationIdNotesRequestBody, application_id: ::String, integration_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::PostAtsApplicationsApplicationIdNotesResponse) }
    def add_application_note(body:, application_id:, integration_id: nil, timeout_ms: nil)
      # add_application_note - Add note to application
      # Add a note to an application.
      # 
      # Add extra information to an application. This can be any extra text information you want to add to an application.
      # 
      # <Note>
      #   This endpoint requires the permission **Add notes** to be enabled in [your scope config](/scopes).
      # </Note>
      # 
      # ### Example Request Body
      # 
      # ```json
      # {
      #   "content": "A new message from the candidate is available in YourChat!",
      #   "content_type": "PLAIN_TEXT",
      #   "remote_fields": {}
      # }
      # ```
      request = Models::Operations::PostAtsApplicationsApplicationIdNotesRequest.new(
        application_id: application_id,
        body: body,
        integration_id: integration_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        Models::Operations::PostAtsApplicationsApplicationIdNotesRequest,
        base_url,
        '/ats/applications/{application_id}/notes',
        request,
        @sdk_configuration.globals
      )
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      req_content_type, data, form = Utils.serialize_request_body(request, false, false, :body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?

      if form
        body = Utils.encode_form(form)
      elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
        body = URI.encode_www_form(T.cast(data, T::Hash[Symbol, Object]))
      else
        body = data
      end
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'PostAtsApplicationsApplicationIdNotes',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).post(url) do |req|
          req.body = body
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::PostAtsApplicationsApplicationIdNotesPositiveResponse)
          response = Models::Operations::PostAtsApplicationsApplicationIdNotesResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            post_ats_applications_application_id_notes_positive_response: T.unsafe(obj)
          )

          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(application_id: ::String, integration_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetAtsApplicationsApplicationIdAttachmentsResponse) }
    def get_application_attachments(application_id:, integration_id: nil, timeout_ms: nil)
      # get_application_attachments - Get application attachments
      # Get attachments from a candidate or application.
      # 
      # Get attachments from an application. If the ATS stores the attachments on the candidate, it will get the attachments from the corresponding candidate instead.
      # 
      # <Note>
      #   This endpoint requires the permission **Read document attachments** to be enabled in [your scope config](/scopes).
      # </Note>
      request = Models::Operations::GetAtsApplicationsApplicationIdAttachmentsRequest.new(
        application_id: application_id,
        integration_id: integration_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        Models::Operations::GetAtsApplicationsApplicationIdAttachmentsRequest,
        base_url,
        '/ats/applications/{application_id}/attachments',
        request,
        @sdk_configuration.globals
      )
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetAtsApplicationsApplicationIdAttachments',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetAtsApplicationsApplicationIdAttachmentsPositiveResponse)
          response = Models::Operations::GetAtsApplicationsApplicationIdAttachmentsResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_ats_applications_application_id_attachments_positive_response: T.unsafe(obj)
          )

          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(body: Models::Shared::PostAtsApplicationsApplicationIdAttachmentsRequestBody, application_id: ::String, integration_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::PostAtsApplicationsApplicationIdAttachmentsResponse) }
    def add_application_attachment(body:, application_id:, integration_id: nil, timeout_ms: nil)
      # add_application_attachment - Add attachment to application
      # Uploads an attachment file for the specified applicant.
      # 
      # <Warning>
      #   If adding an attachment to an application is not supported by the integration, the attachment will be [added to the candidate](/ats/v1/post-candidates-candidate-id-attachments) instead. 
      # </Warning>
      # 
      # <Note>
      #   This endpoint requires the permission **Add attachments** to be enabled in [your scope config](/scopes).
      # </Note>
      # 
      # ### Example Request Body
      # 
      # ```json
      # {
      #   "application_id": "GRKdd9dibYKKCrmGRSMJf3wu",
      #   "attachment": {
      #     "name": "Frank Doe CV.txt",
      #     "data": "SGkgdGhlcmUsIEtvbWJvIGlzIGN1cnJlbnRseSBoaXJpbmcgZW5naW5lZXJzIHRoYXQgbG92ZSB0byB3b3JrIG9uIGRldmVsb3BlciBwcm9kdWN0cy4=",
      #     "type": "CV",
      #     "content_type": "text/plain"
      #   },
      #   "remote_fields": {}
      # }
      # ```
      request = Models::Operations::PostAtsApplicationsApplicationIdAttachmentsRequest.new(
        application_id: application_id,
        body: body,
        integration_id: integration_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        Models::Operations::PostAtsApplicationsApplicationIdAttachmentsRequest,
        base_url,
        '/ats/applications/{application_id}/attachments',
        request,
        @sdk_configuration.globals
      )
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      req_content_type, data, form = Utils.serialize_request_body(request, false, false, :body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?

      if form
        body = Utils.encode_form(form)
      elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
        body = URI.encode_www_form(T.cast(data, T::Hash[Symbol, Object]))
      else
        body = data
      end
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'PostAtsApplicationsApplicationIdAttachments',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).post(url) do |req|
          req.body = body
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::PostAtsApplicationsApplicationIdAttachmentsPositiveResponse)
          response = Models::Operations::PostAtsApplicationsApplicationIdAttachmentsResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            post_ats_applications_application_id_attachments_positive_response: T.unsafe(obj)
          )

          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(body: Models::Shared::PostAtsApplicationsApplicationIdRejectRequestBody, application_id: ::String, integration_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::PostAtsApplicationsApplicationIdRejectResponse) }
    def reject_application(body:, application_id:, integration_id: nil, timeout_ms: nil)
      # reject_application - Reject application
      # Rejects an application with a provided reason.
      # 
      # Rejects an application with a provided reason. Optionally, you can provide a free text note. You can get the list of rejection reasons with our [Get rejection reasons endpoint](/ats/v1/get-rejection-reasons).
      # 
      # <Note>
      #   This endpoint requires the permission **Reject applications** to be enabled in [your scope config](/scopes).
      # </Note>
      # 
      # ### Example Request Body
      # 
      # ```json
      # {
      #   "rejection_reason_id": "3PJ8PZhZZa1eEdd2DtPNtVup",
      #   "note": "Candidate was a great culture fit but didn't bring the hard skills we need.",
      #   "remote_fields": {}
      # }
      # ```
      request = Models::Operations::PostAtsApplicationsApplicationIdRejectRequest.new(
        application_id: application_id,
        body: body,
        integration_id: integration_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        Models::Operations::PostAtsApplicationsApplicationIdRejectRequest,
        base_url,
        '/ats/applications/{application_id}/reject',
        request,
        @sdk_configuration.globals
      )
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      req_content_type, data, form = Utils.serialize_request_body(request, false, false, :body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?

      if form
        body = Utils.encode_form(form)
      elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
        body = URI.encode_www_form(T.cast(data, T::Hash[Symbol, Object]))
      else
        body = data
      end
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'PostAtsApplicationsApplicationIdReject',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).post(url) do |req|
          req.body = body
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::PostAtsApplicationsApplicationIdRejectPositiveResponse)
          response = Models::Operations::PostAtsApplicationsApplicationIdRejectResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            post_ats_applications_application_id_reject_positive_response: T.unsafe(obj)
          )

          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), email: T.nilable(::String), job_ids: T.nilable(T::Array[::String]), first_name: T.nilable(::String), last_name: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetAtsCandidatesResponse) }
    def get_candidates(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, email: nil, job_ids: nil, first_name: nil, last_name: nil, timeout_ms: nil)
      # get_candidates - Get candidates
      # Retrieve all candidates.
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetAtsCandidatesRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids,
        email: email,
        job_ids: job_ids,
        first_name: first_name,
        last_name: last_name
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/ats/candidates"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetAtsCandidatesRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetAtsCandidates',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetAtsCandidatesPositiveResponse)
          response = Models::Operations::GetAtsCandidatesResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_ats_candidates_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_candidates(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids,
              email: email,
              job_ids: job_ids,
              first_name: first_name,
              last_name: last_name
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(body: Models::Shared::PostAtsCandidatesRequestBody, integration_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::PostAtsCandidatesResponse) }
    def create_candidate(body:, integration_id: nil, timeout_ms: nil)
      # create_candidate - Create candidate
      # Create a new candidate and application for the specified job.
      # 
      # <Warning>
      #       **We recommend using the [Create application](/ats/v1/post-jobs-job-id-applications) endpoint instead.**
      # 
      #       We realized that in practice it was always more about creating _applications_ instead of _candidates_, so we created a new, more aptly named one that you should use instead: [Create application](/ats/v1/post-jobs-job-id-applications)
      # 
      #       Using it also has the benefit that we return the newly created applicant at the root level, so you can easily store its ID.
      #     </Warning>
      # 
      # <Note>
      #   This endpoint requires the permission **Create applications and candidates** to be enabled in [your scope config](/scopes).
      # </Note>
      # 
      # ### Example Request Body
      # 
      # ```json
      # {
      #   "candidate": {
      #     "first_name": "Frank",
      #     "last_name": "Doe",
      #     "company": "Acme Inc.",
      #     "title": "Head of Integrations",
      #     "email_address": "frank.doe@example.com",
      #     "phone_number": "+1-541-754-3010",
      #     "gender": "MALE",
      #     "salary_expectations": {
      #       "amount": 100000,
      #       "period": "YEAR"
      #     },
      #     "availability_date": "2021-01-01",
      #     "location": {
      #       "city": "New York",
      #       "country": "US",
      #       "state": "NY"
      #     },
      #     "social_links": [
      #       {
      #         "url": "https://www.linkedin.com/in/frank-doe-123456789/"
      #       },
      #       {
      #         "url": "https://twitter.com/frankdoe"
      #       }
      #     ]
      #   },
      #   "application": {
      #     "job_id": "BDpgnpZ148nrGh4mYHNxJBgx",
      #     "stage_id": "8x3YKRDcuRnwShdh96ShBNn1"
      #   },
      #   "attachments": [
      #     {
      #       "name": "Frank Doe CV.txt",
      #       "data": "SGkgdGhlcmUsIEtvbWJvIGlzIGN1cnJlbnRseSBoaXJpbmcgZW5naW5lZXJzIHRoYXQgbG92ZSB0byB3b3JrIG9uIGRldmVsb3BlciBwcm9kdWN0cy4=",
      #       "type": "CV",
      #       "content_type": "text/plain"
      #     }
      #   ],
      #   "screening_question_answers": [
      #     {
      #       "question_id": "3phFBNXRweGnDmsU9o2vdPuQ",
      #       "answer": "Yes"
      #     },
      #     {
      #       "question_id": "EYJjhMQT3LtVKXnTbnRT8s6U",
      #       "answer": [
      #         "GUzE666zfyjeoCJX6A8n7wh6",
      #         "5WPHzzKAv8cx97KtHRUV96U8",
      #         "7yZfKGzWigXxxRTygqAfHvyE"
      #       ]
      #     }
      #   ],
      #   "remote_fields": {}
      # }
      # ```
      request = Models::Operations::PostAtsCandidatesRequest.new(
        body: body,
        integration_id: integration_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/ats/candidates"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      req_content_type, data, form = Utils.serialize_request_body(request, false, false, :body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?

      if form
        body = Utils.encode_form(form)
      elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
        body = URI.encode_www_form(T.cast(data, T::Hash[Symbol, Object]))
      else
        body = data
      end
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'PostAtsCandidates',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).post(url) do |req|
          req.body = body
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::PostAtsCandidatesPositiveResponse)
          response = Models::Operations::PostAtsCandidatesResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            post_ats_candidates_positive_response: T.unsafe(obj)
          )

          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(candidate_id: ::String, integration_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetAtsCandidatesCandidateIdAttachmentsResponse) }
    def get_candidate_attachments(candidate_id:, integration_id: nil, timeout_ms: nil)
      # get_candidate_attachments - Get candidate attachments
      # Get attachments from a candidate, including all attachments of all of their applications.
      # 
      # <Note>
      #   This endpoint requires the permission **Read document attachments** to be enabled in [your scope config](/scopes).
      # </Note>
      request = Models::Operations::GetAtsCandidatesCandidateIdAttachmentsRequest.new(
        candidate_id: candidate_id,
        integration_id: integration_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        Models::Operations::GetAtsCandidatesCandidateIdAttachmentsRequest,
        base_url,
        '/ats/candidates/{candidate_id}/attachments',
        request,
        @sdk_configuration.globals
      )
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetAtsCandidatesCandidateIdAttachments',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetAtsCandidatesCandidateIdAttachmentsPositiveResponse)
          response = Models::Operations::GetAtsCandidatesCandidateIdAttachmentsResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_ats_candidates_candidate_id_attachments_positive_response: T.unsafe(obj)
          )

          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(body: Models::Shared::PostAtsCandidatesCandidateIdAttachmentsRequestBody, candidate_id: ::String, integration_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::PostAtsCandidatesCandidateIdAttachmentsResponse) }
    def add_candidate_attachment(body:, candidate_id:, integration_id: nil, timeout_ms: nil)
      # add_candidate_attachment - Add attachment to candidate
      # Uploads an attachment file for the specified candidate.
      # 
      # <Warning>
      #   **We recommend using the [add attachment to application](/ats/v1/post-applications-application-id-attachments) endpoint instead.**
      # 
      #   We realized that in practice it was always more about adding attachments to _applications_ instead of _candidates_, so we created a new, more aptly named one that you should use instead: [add attachment to application](/ats/v1/post-applications-application-id-attachments)
      #   </Warning>
      # 
      # <Note>
      #   This endpoint requires the permission **Add attachments** to be enabled in [your scope config](/scopes).
      # </Note>
      # 
      # ### Example Request Body
      # 
      # ```json
      # {
      #   "candidate_id": "GRKdd9dibYKKCrmGRSMJf3wu",
      #   "attachment": {
      #     "name": "Frank Doe CV.txt",
      #     "data": "SGkgdGhlcmUsIEtvbWJvIGlzIGN1cnJlbnRseSBoaXJpbmcgZW5naW5lZXJzIHRoYXQgbG92ZSB0byB3b3JrIG9uIGRldmVsb3BlciBwcm9kdWN0cy4=",
      #     "type": "CV",
      #     "content_type": "text/plain"
      #   }
      # }
      # ```
      request = Models::Operations::PostAtsCandidatesCandidateIdAttachmentsRequest.new(
        candidate_id: candidate_id,
        body: body,
        integration_id: integration_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        Models::Operations::PostAtsCandidatesCandidateIdAttachmentsRequest,
        base_url,
        '/ats/candidates/{candidate_id}/attachments',
        request,
        @sdk_configuration.globals
      )
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      req_content_type, data, form = Utils.serialize_request_body(request, false, false, :body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?

      if form
        body = Utils.encode_form(form)
      elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
        body = URI.encode_www_form(T.cast(data, T::Hash[Symbol, Object]))
      else
        body = data
      end
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'PostAtsCandidatesCandidateIdAttachments',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).post(url) do |req|
          req.body = body
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::PostAtsCandidatesCandidateIdAttachmentsPositiveResponse)
          response = Models::Operations::PostAtsCandidatesCandidateIdAttachmentsResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            post_ats_candidates_candidate_id_attachments_positive_response: T.unsafe(obj)
          )

          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(body: Models::Shared::PostAtsCandidatesCandidateIdResultLinksRequestBody, candidate_id: ::String, integration_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::PostAtsCandidatesCandidateIdResultLinksResponse) }
    def add_candidate_result_link(body:, candidate_id:, integration_id: nil, timeout_ms: nil)
      # add_candidate_result_link - Add result link to candidate
      # Add a result link to a candidate.
      # 
      # <Warning>
      #   **We recommend to use [add result link to application](/ats/v1/post-applications-application-id-result-links) instead.**
      # 
      #   This can, for example, be used to link a candidate back to a test result/assessment in your application. As not all ATS tools have a "result link" feature, we sometimes repurpose other fields to expose it.
      # 
      #   </Warning>
      #   
      # 
      # <Note>
      #   This endpoint requires the permission **Add result links** to be enabled in [your scope config](/scopes).
      # </Note>
      # 
      # ### Example Request Body
      # 
      # ```json
      # {
      #   "label": "Assessment Result",
      #   "url": "https://example.com/test-results/5BtP1WC1UboS7CF3yxjKcvjG",
      #   "details": {
      #     "custom_field_name_prefix": "Acme:",
      #     "attributes": [
      #       {
      #         "key": "Score",
      #         "value": "100%"
      #       },
      #       {
      #         "key": "Time",
      #         "value": "2:30h"
      #       }
      #     ]
      #   },
      #   "remote_fields": {}
      # }
      # ```
      request = Models::Operations::PostAtsCandidatesCandidateIdResultLinksRequest.new(
        candidate_id: candidate_id,
        body: body,
        integration_id: integration_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        Models::Operations::PostAtsCandidatesCandidateIdResultLinksRequest,
        base_url,
        '/ats/candidates/{candidate_id}/result-links',
        request,
        @sdk_configuration.globals
      )
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      req_content_type, data, form = Utils.serialize_request_body(request, false, false, :body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?

      if form
        body = Utils.encode_form(form)
      elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
        body = URI.encode_www_form(T.cast(data, T::Hash[Symbol, Object]))
      else
        body = data
      end
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'PostAtsCandidatesCandidateIdResultLinks',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).post(url) do |req|
          req.body = body
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::PostAtsCandidatesCandidateIdResultLinksPositiveResponse)
          response = Models::Operations::PostAtsCandidatesCandidateIdResultLinksResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            post_ats_candidates_candidate_id_result_links_positive_response: T.unsafe(obj)
          )

          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(body: Models::Shared::PostAtsCandidatesCandidateIdTagsRequestBody, candidate_id: ::String, integration_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::PostAtsCandidatesCandidateIdTagsResponse) }
    def add_candidate_tag(body:, candidate_id:, integration_id: nil, timeout_ms: nil)
      # add_candidate_tag - Add tag to candidate
      # Add a tag to a candidate.
      # 
      # Kombo takes care of creating the tag if required, finding out the right ID, and appending it to the list of tags.
      # 
      # <Note>
      #   This endpoint requires the permission **Manage tags** to be enabled in [your scope config](/scopes).
      # </Note>
      # 
      # ### Example Request Body
      # 
      # ```json
      # {
      #   "tag": {
      #     "name": "Excellent Fit"
      #   }
      # }
      # ```
      request = Models::Operations::PostAtsCandidatesCandidateIdTagsRequest.new(
        candidate_id: candidate_id,
        body: body,
        integration_id: integration_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        Models::Operations::PostAtsCandidatesCandidateIdTagsRequest,
        base_url,
        '/ats/candidates/{candidate_id}/tags',
        request,
        @sdk_configuration.globals
      )
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      req_content_type, data, form = Utils.serialize_request_body(request, false, false, :body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?

      if form
        body = Utils.encode_form(form)
      elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
        body = URI.encode_www_form(T.cast(data, T::Hash[Symbol, Object]))
      else
        body = data
      end
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'PostAtsCandidatesCandidateIdTags',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).post(url) do |req|
          req.body = body
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::PostAtsCandidatesCandidateIdTagsPositiveResponse)
          response = Models::Operations::PostAtsCandidatesCandidateIdTagsResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            post_ats_candidates_candidate_id_tags_positive_response: T.unsafe(obj)
          )

          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(body: Models::Shared::DeleteAtsCandidatesCandidateIdTagsRequestBody, candidate_id: ::String, integration_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::DeleteAtsCandidatesCandidateIdTagsResponse) }
    def remove_candidate_tag(body:, candidate_id:, integration_id: nil, timeout_ms: nil)
      # remove_candidate_tag - Remove tag from candidate
      # Remove a tag from a candidate based on its name.
      # 
      # This will also succeed if the tag does not exist on the candidate.
      # 
      # <Note>
      #   This endpoint requires the permission **Manage tags** to be enabled in [your scope config](/scopes).
      # </Note>
      # 
      # ### Example Request Body
      # 
      # ```json
      # {
      #   "tag": {
      #     "name": "Excellent Fit"
      #   }
      # }
      # ```
      request = Models::Operations::DeleteAtsCandidatesCandidateIdTagsRequest.new(
        candidate_id: candidate_id,
        body: body,
        integration_id: integration_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        Models::Operations::DeleteAtsCandidatesCandidateIdTagsRequest,
        base_url,
        '/ats/candidates/{candidate_id}/tags',
        request,
        @sdk_configuration.globals
      )
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      req_content_type, data, form = Utils.serialize_request_body(request, false, false, :body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?

      if form
        body = Utils.encode_form(form)
      elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
        body = URI.encode_www_form(T.cast(data, T::Hash[Symbol, Object]))
      else
        body = data
      end
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'DeleteAtsCandidatesCandidateIdTags',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).delete(url) do |req|
          req.body = body
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::DeleteAtsCandidatesCandidateIdTagsPositiveResponse)
          response = Models::Operations::DeleteAtsCandidatesCandidateIdTagsResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            delete_ats_candidates_candidate_id_tags_positive_response: T.unsafe(obj)
          )

          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetAtsTagsResponse) }
    def get_tags(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, timeout_ms: nil)
      # get_tags - Get tags
      # Retrieve all tags.
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetAtsTagsRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/ats/tags"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetAtsTagsRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetAtsTags',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetAtsTagsPositiveResponse)
          response = Models::Operations::GetAtsTagsResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_ats_tags_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_tags(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetAtsApplicationStagesResponse) }
    def get_application_stages(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, timeout_ms: nil)
      # get_application_stages - Get application stages
      # Get all application stages available in the ATS.
      # 
      # <Warning>
      #   **This endpoint is deprecated!**
      # 
      #   Get all application stages available in the ATS. This is deprecated because most ATS systems have separate sets of stages for each job. We'd recommend using the `stages` property from the [GET Jobs endpoint](/ats/v1/get-jobs) instead.
      # 
      # **Important**: Using global stages can cause "Stage not found" errors when moving applications, especially with systems like Workable that have job-specific stages.
      # 
      # [Moving Applications Guide](/ats/implementation-guide/moving-and-rejecting-candidates).
      # </Warning>
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetAtsApplicationStagesRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/ats/application-stages"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetAtsApplicationStagesRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetAtsApplicationStages',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetAtsApplicationStagesPositiveResponse)
          response = Models::Operations::GetAtsApplicationStagesResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_ats_application_stages_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_application_stages(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), job_codes: T.nilable(T::Array[::String]), post_url: T.nilable(::String), statuses: T.nilable(T::Array[::String]), employment_types: T.nilable(T::Array[::String]), visibilities: T.nilable(T::Array[::String]), remote_created_after: T.nilable(::DateTime), name_contains: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetAtsJobsResponse) }
    def get_jobs(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, job_codes: nil, post_url: nil, statuses: nil, employment_types: nil, visibilities: nil, remote_created_after: nil, name_contains: nil, timeout_ms: nil)
      # get_jobs - Get jobs
      # Retrieve all jobs.
      # 
      # Visit our in-depth guides to learn more about:
      # 
      # - ðŸ”„ [Getting updates of the data](/ats/features/implementation-guide/reading-jobs#getting-updates-of-the-data)
      # - â— [Handling failing syncs](/ats/features/implementation-guide/reading-jobs#handling-failing-syncs)
      # - ðŸ” [Letting your customer choose which jobs to expose](/ats/features/implementation-guide/reading-jobs#let-your-customer-choose-which-jobs-to-expose-to-you)
      # - ðŸ”— [Matching jobs in your database to ATS jobs](/ats/features/implementation-guide/reading-jobs#match-jobs-in-your-database-to-ats-jobs)
      # - ðŸ—‘ï¸ [Reacting to deleted/closed jobs](/ats/features/implementation-guide/reading-jobs#reacting-to-deleted-closed-jobs)
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetAtsJobsRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids,
        job_codes: job_codes,
        post_url: post_url,
        statuses: statuses,
        employment_types: employment_types,
        visibilities: visibilities,
        remote_created_after: remote_created_after,
        name_contains: name_contains
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/ats/jobs"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetAtsJobsRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetAtsJobs',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetAtsJobsPositiveResponse)
          response = Models::Operations::GetAtsJobsResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_ats_jobs_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_jobs(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids,
              job_codes: job_codes,
              post_url: post_url,
              statuses: statuses,
              employment_types: employment_types,
              visibilities: visibilities,
              remote_created_after: remote_created_after,
              name_contains: name_contains
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(body: Models::Shared::PostAtsJobsJobIdApplicationsRequestBody, job_id: ::String, integration_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::PostAtsJobsJobIdApplicationsResponse) }
    def create_application(body:, job_id:, integration_id: nil, timeout_ms: nil)
      # create_application - Create application
      # Create a new application and candidate for the specified job.
      # 
      # Visit our in-depth guides to learn more about:
      # 
      # - ðŸŒ [Setting the source of the application](/ats/features/implementation-guide/creating-applications#set-the-source-of-the-application) 
      # - ðŸ“Ž [Uploading attachments with the application](/ats/features/implementation-guide/creating-applications#upload-attachments-with-the-application) 
      # - â™»ï¸ [Retry behaviour](/ats/features/implementation-guide/creating-applications#retry-behaviour) 
      # - âœï¸ [Writing answers to screening questions](/ats/features/implementation-guide/creating-applications#write-answers-to-screening-questions) 
      # - âš ï¸ [Handling ATS-specific limitations](/ats/features/implementation-guide/creating-applications#handle-ats-specific-limitations)
      # 
      # <Note>
      #   This endpoint requires the permission **Create applications and candidates** to be enabled in [your scope config](/scopes).
      # </Note>
      # 
      # ### Example Request Body
      # 
      # ```json
      # {
      #   "candidate": {
      #     "first_name": "Frank",
      #     "last_name": "Doe",
      #     "company": "Acme Inc.",
      #     "title": "Head of Integrations",
      #     "email_address": "frank.doe@example.com",
      #     "phone_number": "+1-541-754-3010",
      #     "gender": "MALE",
      #     "salary_expectations": {
      #       "amount": 100000,
      #       "period": "YEAR"
      #     },
      #     "availability_date": "2021-01-01",
      #     "location": {
      #       "city": "New York",
      #       "country": "US"
      #     }
      #   },
      #   "stage_id": "8x3YKRDcuRnwShdh96ShBNn1",
      #   "attachments": [
      #     {
      #       "name": "Frank Doe CV.txt",
      #       "data": "SGkgdGhlcmUsIEtvbWJvIGlzIGN1cnJlbnRseSBoaXJpbmcgZW5naW5lZXJzIHRoYXQgbG92ZSB0byB3b3JrIG9uIGRldmVsb3BlciBwcm9kdWN0cy4=",
      #       "type": "CV",
      #       "content_type": "text/plain"
      #     }
      #   ],
      #   "screening_question_answers": [
      #     {
      #       "question_id": "3phFBNXRweGnDmsU9o2vdPuQ",
      #       "answer": "Yes"
      #     },
      #     {
      #       "question_id": "EYJjhMQT3LtVKXnTbnRT8s6U",
      #       "answer": [
      #         "GUzE666zfyjeoCJX6A8n7wh6",
      #         "5WPHzzKAv8cx97KtHRUV96U8",
      #         "7yZfKGzWigXxxRTygqAfHvyE"
      #       ]
      #     }
      #   ],
      #   "remote_fields": {}
      # }
      # ```
      request = Models::Operations::PostAtsJobsJobIdApplicationsRequest.new(
        job_id: job_id,
        body: body,
        integration_id: integration_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = Utils.generate_url(
        Models::Operations::PostAtsJobsJobIdApplicationsRequest,
        base_url,
        '/ats/jobs/{job_id}/applications',
        request,
        @sdk_configuration.globals
      )
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      req_content_type, data, form = Utils.serialize_request_body(request, false, false, :body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?

      if form
        body = Utils.encode_form(form)
      elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
        body = URI.encode_www_form(T.cast(data, T::Hash[Symbol, Object]))
      else
        body = data
      end
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'PostAtsJobsJobIdApplications',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).post(url) do |req|
          req.body = body
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::PostAtsJobsJobIdApplicationsPositiveResponse)
          response = Models::Operations::PostAtsJobsJobIdApplicationsResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            post_ats_jobs_job_id_applications_positive_response: T.unsafe(obj)
          )

          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), emails: T.nilable(T::Array[::String]), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetAtsUsersResponse) }
    def get_users(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, emails: nil, timeout_ms: nil)
      # get_users - Get users
      # Retrieve all users.
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetAtsUsersRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids,
        emails: emails
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/ats/users"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetAtsUsersRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetAtsUsers',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetAtsUsersPositiveResponse)
          response = Models::Operations::GetAtsUsersResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_ats_users_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_users(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids,
              emails: emails
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetAtsOffersResponse) }
    def get_offers(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, timeout_ms: nil)
      # get_offers - Get offers
      # Retrieve all offers.
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetAtsOffersRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/ats/offers"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetAtsOffersRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetAtsOffers',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetAtsOffersPositiveResponse)
          response = Models::Operations::GetAtsOffersResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_ats_offers_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_offers(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetAtsRejectionReasonsResponse) }
    def get_rejection_reasons(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, timeout_ms: nil)
      # get_rejection_reasons - Get rejection reasons
      # Retrieve all rejection reasons.
      # 
      # Get all rejection reasons available in the system. The Kombo ID is required in the associated [reject application action](/ats/v1/post-applications-application-id-reject).
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetAtsRejectionReasonsRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/ats/rejection-reasons"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetAtsRejectionReasonsRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetAtsRejectionReasons',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetAtsRejectionReasonsPositiveResponse)
          response = Models::Operations::GetAtsRejectionReasonsResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_ats_rejection_reasons_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_rejection_reasons(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), page_size: T.nilable(::Integer), updated_after: T.nilable(::DateTime), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), job_ids: T.nilable(T::Array[::String]), timeout_ms: T.nilable(Integer)).returns(Models::Operations::GetAtsInterviewsResponse) }
    def get_interviews(integration_id: nil, cursor: nil, page_size: nil, updated_after: nil, include_deleted: nil, ignore_unsupported_filters: nil, ids: nil, remote_ids: nil, job_ids: nil, timeout_ms: nil)
      # get_interviews - Get interviews
      # Retrieve all interviews.
      # 
      # Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
      request = Models::Operations::GetAtsInterviewsRequest.new(
        integration_id: integration_id,
        cursor: cursor,
        page_size: page_size,
        updated_after: updated_after,
        include_deleted: include_deleted,
        ignore_unsupported_filters: ignore_unsupported_filters,
        ids: ids,
        remote_ids: remote_ids,
        job_ids: job_ids
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/ats/interviews"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      query_params = Utils.get_query_params(Models::Operations::GetAtsInterviewsRequest, request, nil, @sdk_configuration.globals)
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'GetAtsInterviews',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).get(url) do |req|
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          req.params = query_params
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::GetAtsInterviewsPositiveResponse)
          response = Models::Operations::GetAtsInterviewsResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            get_ats_interviews_positive_response: T.unsafe(obj)
          )
          sdk = self

          response.next_page = proc do 
            next_cursor = Janeway.enum_for('$.data.next', JSON.parse(response_data)).search
            if next_cursor.nil?
              next nil
            else
              next_cursor = next_cursor[0]
              if next_cursor.nil?
                next nil
              end
            end

            sdk.get_interviews(
              integration_id: integration_id,
              cursor: next_cursor,
              page_size: page_size,
              updated_after: updated_after,
              include_deleted: include_deleted,
              ignore_unsupported_filters: ignore_unsupported_filters,
              ids: ids,
              remote_ids: remote_ids,
              job_ids: job_ids
            )
          end


          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end


    sig { params(body: Models::Shared::PostAtsImportTrackedApplicationRequestBody, integration_id: T.nilable(::String), timeout_ms: T.nilable(Integer)).returns(Models::Operations::PostAtsImportTrackedApplicationResponse) }
    def import_tracked_application(body:, integration_id: nil, timeout_ms: nil)
      # import_tracked_application - Import tracked application
      # Import tracked application
      # 
      # Retroactively import existing applications into Kombo's tracking system. This is particularly useful if you have enabled the 'sync only created applications' setting and want to start tracking applications that were created before using Kombo.
      # 
      # To import an application, you'll need to provide specific identifiers based on the ATS. The available `id_type` values are defined by Kombo based on the tool's API capabilities. Please reach out to Kombo support if you require further types to be supported.
      # 
      # Once imported, Kombo will automatically fetch and update the application's complete data during the next sync.
      # 
      # ### Example Request Body
      # 
      # ```json
      # {
      #   "tracked_at": "2024-04-12T14:33:47.000Z",
      #   "successfactors": {
      #     "id_type": "application_remote_id",
      #     "application_remote_id": "1224042"
      #   }
      # }
      # ```
      request = Models::Operations::PostAtsImportTrackedApplicationRequest.new(
        body: body,
        integration_id: integration_id
      )
      url, params = @sdk_configuration.get_server_details
      base_url = Utils.template_url(url, params)
      url = "#{base_url}/ats/import-tracked-application"
      headers = Utils.get_headers(request, @sdk_configuration.globals)
      headers = T.cast(headers, T::Hash[String, String])
      req_content_type, data, form = Utils.serialize_request_body(request, false, false, :body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?

      if form
        body = Utils.encode_form(form)
      elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
        body = URI.encode_www_form(T.cast(data, T::Hash[Symbol, Object]))
      else
        body = data
      end
      headers['Accept'] = 'application/json'
      headers['user-agent'] = @sdk_configuration.user_agent

      security = @sdk_configuration.security_source&.call

      timeout = (timeout_ms.to_f / 1000) unless timeout_ms.nil?
      timeout ||= @sdk_configuration.timeout
      

      connection = @sdk_configuration.client

      hook_ctx = SDKHooks::HookContext.new(
        config: @sdk_configuration,
        base_url: base_url,
        oauth2_scopes: nil,
        operation_id: 'PostAtsImportTrackedApplication',
        security_source: @sdk_configuration.security_source
      )

      error = T.let(nil, T.nilable(StandardError))
      http_response = T.let(nil, T.nilable(Faraday::Response))
      
      
      begin
        http_response = T.must(connection).post(url) do |req|
          req.body = body
          req.headers.merge!(headers)
          req.options.timeout = timeout unless timeout.nil?
          Utils.configure_request_security(req, security)

          @sdk_configuration.hooks.before_request(
            hook_ctx: SDKHooks::BeforeRequestHookContext.new(
              hook_ctx: hook_ctx
            ),
            request: req
          )
        end
      rescue StandardError => e
        error = e
      ensure
        if http_response.nil? || Utils.error_status?(http_response.status)
          http_response = @sdk_configuration.hooks.after_error(
            error: error,
            hook_ctx: SDKHooks::AfterErrorHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        else
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
        end
        
        if http_response.nil?
          raise error if !error.nil?
          raise 'no response'
        end
      end
      
      content_type = http_response.headers.fetch('Content-Type', 'application/octet-stream')
      if Utils.match_status_code(http_response.status, ['200'])
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Shared::PostAtsImportTrackedApplicationPositiveResponse)
          response = Models::Operations::PostAtsImportTrackedApplicationResponse.new(
            status_code: http_response.status,
            content_type: content_type,
            raw_response: http_response,
            post_ats_import_tracked_application_positive_response: T.unsafe(obj)
          )

          return response
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      else
        if Utils.match_content_type(content_type, 'application/json')
          http_response = @sdk_configuration.hooks.after_success(
            hook_ctx: SDKHooks::AfterSuccessHookContext.new(
              hook_ctx: hook_ctx
            ),
            response: http_response
          )
          response_data = http_response.env.response_body
          obj = Crystalline.unmarshal_json(JSON.parse(response_data), Models::Errors::KomboAtsError)
          obj.raw_response = http_response
          raise obj
        else
          raise ::OpenApiSDK::Models::Errors::APIError.new(status_code: http_response.status, body: http_response.env.response_body, raw_response: http_response), 'Unknown content type received'
        end
      end
    end
  end
end
