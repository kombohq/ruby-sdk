# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true


module Kombo
  module Models
    module Operations

      class GetHrisTimesheetsRequest
        extend T::Sig
        include Crystalline::MetadataFields

        # ID of the integration you want to interact with.
        field :integration_id, Crystalline::Nilable.new(::String), { 'header': { 'field_name': 'X-Integration-Id', 'style': 'simple', 'explode': false } }
        # An optional cursor string used for pagination. This can be retrieved from the `next` property of the previous page response.
        field :cursor, Crystalline::Nilable.new(::String), { 'query_param': { 'field_name': 'cursor', 'style': 'form', 'explode': true } }
        # Filter the entries based on the modification date in format `YYYY-MM-DDTHH:mm:ss.sssZ`. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record's own `changed_at` field remains unchanged.
        #
        # If you want to track entry deletion, also set the `include_deleted=true` query parameter, because otherwise, deleted entries will be hidden.
        #
        # For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
        field :updated_after, Crystalline::Nilable.new(::DateTime), { 'query_param': { 'field_name': 'updated_after', 'style': 'form', 'explode': true } }
        # Filter by a comma-separated list of IDs such as `222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3`.
        field :ids, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'query_param': { 'field_name': 'ids', 'style': 'form', 'explode': false } }
        # Filter by a comma-separated list of remote IDs.
        field :remote_ids, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'query_param': { 'field_name': 'remote_ids', 'style': 'form', 'explode': false } }
        # Returns timesheets for a specific employee.
        field :employee_id, Crystalline::Nilable.new(::String), { 'query_param': { 'field_name': 'employee_id', 'style': 'form', 'explode': true } }
        # Return timesheets whose start time is before the given timestamp.
        field :started_before, Crystalline::Nilable.new(::DateTime), { 'query_param': { 'field_name': 'started_before', 'style': 'form', 'explode': true } }
        # Return timesheets whose start time is on or after the given timestamp.
        field :started_after, Crystalline::Nilable.new(::DateTime), { 'query_param': { 'field_name': 'started_after', 'style': 'form', 'explode': true } }
        # Return timesheets whose end time is on or before the given timestamp.
        field :ended_before, Crystalline::Nilable.new(::DateTime), { 'query_param': { 'field_name': 'ended_before', 'style': 'form', 'explode': true } }
        # Return timesheets whose end time is on or after the given timestamp.
        field :ended_after, Crystalline::Nilable.new(::DateTime), { 'query_param': { 'field_name': 'ended_after', 'style': 'form', 'explode': true } }
        # The number of results to return per page. Maximum is 250.
        field :page_size, Crystalline::Nilable.new(::Integer), { 'query_param': { 'field_name': 'page_size', 'style': 'form', 'explode': true } }
        # By default, deleted entries are not returned. Use the `include_deleted` query param to include deleted entries too.
        field :include_deleted, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'query_param': { 'field_name': 'include_deleted', 'style': 'form', 'explode': true } }
        # When set to `true`, filters targeting fields not supported by this integration will be ignored instead of filtering out all results.
        field :ignore_unsupported_filters, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'query_param': { 'field_name': 'ignore_unsupported_filters', 'style': 'form', 'explode': true } }

        sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), updated_after: T.nilable(::DateTime), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), employee_id: T.nilable(::String), started_before: T.nilable(::DateTime), started_after: T.nilable(::DateTime), ended_before: T.nilable(::DateTime), ended_after: T.nilable(::DateTime), page_size: T.nilable(::Integer), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean)).void }
        def initialize(integration_id: nil, cursor: nil, updated_after: nil, ids: nil, remote_ids: nil, employee_id: nil, started_before: nil, started_after: nil, ended_before: nil, ended_after: nil, page_size: 100, include_deleted: false, ignore_unsupported_filters: false)
          @integration_id = integration_id
          @cursor = cursor
          @updated_after = updated_after
          @ids = ids
          @remote_ids = remote_ids
          @employee_id = employee_id
          @started_before = started_before
          @started_after = started_after
          @ended_before = ended_before
          @ended_after = ended_after
          @page_size = page_size
          @include_deleted = include_deleted
          @ignore_unsupported_filters = ignore_unsupported_filters
        end

        sig { params(other: T.untyped).returns(T::Boolean) }
        def ==(other)
          return false unless other.is_a? self.class
          return false unless @integration_id == other.integration_id
          return false unless @cursor == other.cursor
          return false unless @updated_after == other.updated_after
          return false unless @ids == other.ids
          return false unless @remote_ids == other.remote_ids
          return false unless @employee_id == other.employee_id
          return false unless @started_before == other.started_before
          return false unless @started_after == other.started_after
          return false unless @ended_before == other.ended_before
          return false unless @ended_after == other.ended_after
          return false unless @page_size == other.page_size
          return false unless @include_deleted == other.include_deleted
          return false unless @ignore_unsupported_filters == other.ignore_unsupported_filters
          true
        end
      end
    end
  end
end
