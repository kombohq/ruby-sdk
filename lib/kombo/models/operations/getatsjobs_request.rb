# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true


module Kombo
  module Models
    module Operations

      class GetAtsJobsRequest
        extend T::Sig
        include Crystalline::MetadataFields

        # ID of the integration you want to interact with.
        field :integration_id, Crystalline::Nilable.new(::String), { 'header': { 'field_name': 'X-Integration-Id', 'style': 'simple', 'explode': false } }
        # An optional cursor string used for pagination. This can be retrieved from the `next` property of the previous page response.
        field :cursor, Crystalline::Nilable.new(::String), { 'query_param': { 'field_name': 'cursor', 'style': 'form', 'explode': true } }
        # Filter the entries based on the modification date in format `YYYY-MM-DDTHH:mm:ss.sssZ`. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record's own `changed_at` field remains unchanged.
        # 
        # If you want to track entry deletion, also set the `include_deleted=true` query parameter, because otherwise, deleted entries will be hidden.
        # 
        # For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
        field :updated_after, Crystalline::Nilable.new(::DateTime), { 'query_param': { 'field_name': 'updated_after', 'style': 'form', 'explode': true } }
        # Filter by a comma-separated list of IDs such as `222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3`.
        field :ids, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'query_param': { 'field_name': 'ids', 'style': 'form', 'explode': false } }
        # Filter by a comma-separated list of remote IDs.
        field :remote_ids, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'query_param': { 'field_name': 'remote_ids', 'style': 'form', 'explode': false } }
        # Filter by a comma-separated list of job codes.
        field :job_codes, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'query_param': { 'field_name': 'job_codes', 'style': 'form', 'explode': false } }
        # Filter by the `post_url` field. Can be used to find a job based on its public posting URL.
        field :post_url, Crystalline::Nilable.new(::String), { 'query_param': { 'field_name': 'post_url', 'style': 'form', 'explode': true } }
        # Filter by a comma-separated list of `OPEN`, `CLOSED`, `DRAFT`, `ARCHIVED`  
        # 
        # Leave this blank to get results matching all values.
        field :statuses, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'query_param': { 'field_name': 'statuses', 'style': 'form', 'explode': false } }
        # Filter by a comma-separated list of `FULL_TIME`, `PART_TIME`, `CONTRACT`, `SEASONAL`, `INTERNSHIP`  
        # 
        # Leave this blank to get results matching all values.
        field :employment_types, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'query_param': { 'field_name': 'employment_types', 'style': 'form', 'explode': false } }
        # Filter by a comma-separated list of `PUBLIC`, `INTERNAL`, `UNLISTED`, `CONFIDENTIAL`  
        # 
        # Leave this blank to get results matching all values.
        field :visibilities, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'query_param': { 'field_name': 'visibilities', 'style': 'form', 'explode': false } }
        # Filter jobs by the day they were created in the remote system. This allows you to get jobs that were created on or after a certain day.
        field :remote_created_after, Crystalline::Nilable.new(::DateTime), { 'query_param': { 'field_name': 'remote_created_after', 'style': 'form', 'explode': true } }
        # Filter by the `name` field. Can be used to find a job by keywords present in the job name.
        field :name_contains, Crystalline::Nilable.new(::String), { 'query_param': { 'field_name': 'name_contains', 'style': 'form', 'explode': true } }
        # The number of results to return per page. Maximum is 250.
        field :page_size, Crystalline::Nilable.new(::Integer), { 'query_param': { 'field_name': 'page_size', 'style': 'form', 'explode': true } }
        # By default, deleted entries are not returned. Use the `include_deleted` query param to include deleted entries too.
        field :include_deleted, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'query_param': { 'field_name': 'include_deleted', 'style': 'form', 'explode': true } }
        # When set to `true`, filters targeting fields not supported by this integration will be ignored instead of filtering out all results.
        field :ignore_unsupported_filters, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'query_param': { 'field_name': 'ignore_unsupported_filters', 'style': 'form', 'explode': true } }

        sig { params(integration_id: T.nilable(::String), cursor: T.nilable(::String), updated_after: T.nilable(::DateTime), ids: T.nilable(T::Array[::String]), remote_ids: T.nilable(T::Array[::String]), job_codes: T.nilable(T::Array[::String]), post_url: T.nilable(::String), statuses: T.nilable(T::Array[::String]), employment_types: T.nilable(T::Array[::String]), visibilities: T.nilable(T::Array[::String]), remote_created_after: T.nilable(::DateTime), name_contains: T.nilable(::String), page_size: T.nilable(::Integer), include_deleted: T.nilable(T::Boolean), ignore_unsupported_filters: T.nilable(T::Boolean)).void }
        def initialize(integration_id: nil, cursor: nil, updated_after: nil, ids: nil, remote_ids: nil, job_codes: nil, post_url: nil, statuses: nil, employment_types: nil, visibilities: nil, remote_created_after: nil, name_contains: nil, page_size: 100, include_deleted: false, ignore_unsupported_filters: false)
          @integration_id = integration_id
          @cursor = cursor
          @updated_after = updated_after
          @ids = ids
          @remote_ids = remote_ids
          @job_codes = job_codes
          @post_url = post_url
          @statuses = statuses
          @employment_types = employment_types
          @visibilities = visibilities
          @remote_created_after = remote_created_after
          @name_contains = name_contains
          @page_size = page_size
          @include_deleted = include_deleted
          @ignore_unsupported_filters = ignore_unsupported_filters
        end

        sig { params(other: T.untyped).returns(T::Boolean) }
        def ==(other)
          return false unless other.is_a? self.class
          return false unless @integration_id == other.integration_id
          return false unless @cursor == other.cursor
          return false unless @updated_after == other.updated_after
          return false unless @ids == other.ids
          return false unless @remote_ids == other.remote_ids
          return false unless @job_codes == other.job_codes
          return false unless @post_url == other.post_url
          return false unless @statuses == other.statuses
          return false unless @employment_types == other.employment_types
          return false unless @visibilities == other.visibilities
          return false unless @remote_created_after == other.remote_created_after
          return false unless @name_contains == other.name_contains
          return false unless @page_size == other.page_size
          return false unless @include_deleted == other.include_deleted
          return false unless @ignore_unsupported_filters == other.ignore_unsupported_filters
          true
        end
      end
    end
  end
end
